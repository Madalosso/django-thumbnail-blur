{
  "name": "Django-thumbnail-blur",
  "tagline": "Create thumbnails from ImageField plus a blurred [9,9] px image.",
  "body": "# Django Image Preview with Dominant or Blurred images.\r\n\r\n### The problem.\r\nImage load is a major topic when the subject is fast load and presentation of a website or web application. I've recently learned and coded a solution that I think you guys could use in your own projects.\r\n\r\nFirst of all, I expect anyone in here to know the concept of thumbnails, if you don't, make a quick search then get back :)\r\n\r\n### The context\r\nI've created this solution on a Django App that works as an API to provide information to another app. In this application, the admin had to be able to upload Images to fill a ImageField of one of my models.\r\n\r\nAs the admins who provide those images to the app aren't trained to treat the images for web, i need my app to do it for them.\r\n\r\n### The solution\r\nFirst thing to do: Create thumbnails\r\nThere are a lot of good packages to create thumbnails that you can find in [djangopackages.com](https://www.djangopackages.com/search/?q=thumbnails).\r\n\r\nI chose to create my own solution using the \"[PIllow](http://pillow.readthedocs.io/en/3.2.x/)\"- a fork of Python Imaging Library that provides lots of resources. Pillow has a module called \"Image\" with a thumbnail function, this function will re-size your image with the size that you provide as an argument and will remove [ExIf](https://en.wikipedia.org/wiki/Exchangeable_image_file_format) as well, creating a lighter version of your original file.\r\n\r\n### Show me the code\r\nHere is where everything happens. While my model.py defines a class with 3 ImageFields, only one field is shown on my django admin, this way, the admin will provide only one picture, and the form will override the standard save method, using him to create other versions of the original picture.\r\nforms.py:\r\n``` python\r\nfrom django import forms\r\nfrom models import Picture\r\nfrom PIL import Image\r\nimport base64\r\nimport StringIO\r\nfrom django.core.files.uploadedfile import InMemoryUploadedFile\r\n\r\ndef generate_resized_image(source, size):\r\n    img_l = Image.open(source)\r\n    img_l.thumbnail(size, Image.ANTIALIAS)\r\n    data_img = StringIO.StringIO()\r\n    img_l.save(data_img, 'JPEG')\r\n    img_l.close()\r\n    img_temp_file = InMemoryUploadedFile(data_img, None,\r\n                                         str(size[0]) + '.jpg', 'image/jpeg',\r\n                                         data_img.len, None)\r\n    return img_temp_file\r\n\r\nclass PictureForm(forms.ModelForm):\r\n    class Meta:\r\n        model = Picture\r\n        fields = ['title', 'description', 'img_l']\r\n\r\n    def save(self, commit=True):\r\n        instance = super(PictureForm, self).save(commit=False)\r\n        source = instance.img_l\r\n        size_img_l = 1920, 1080\r\n        size_img_m = 1366, 768\r\n        size_img_s = 768, 432\r\n        size_img_blur = 9, 9\r\n        instance.save()\r\n        img1 = generate_resized_image(source, size_img_l)\r\n        instance.img_l = img1\r\n        instance.img_m = generate_resized_image(source, size_img_m)\r\n        instance.img_s = generate_resized_image(source, size_img_s)\r\n        instance.save()\r\n        return instance\r\n```\r\nadmin.py:\r\n``` python\r\nfrom django.contrib import admin\r\nfrom models import Picture\r\nfrom forms import PictureForm\r\n\r\n\r\nclass PictureAdmin(admin.ModelAdmin):\r\n    model = Picture\r\n    form = PictureForm\r\n    verbose_name = \"Picture\"\r\n    verbose_name_plural = \"Pictures\"\r\n    list_display = ('id', 'title', 'description', 'img_s',\r\n                    'img_m', 'img_l', 'img_blur')\r\n\r\n\r\nadmin.site.register(Picture, PictureAdmin)\r\n```\r\nmodels.py\r\n``` python\r\nfrom __future__ import unicode_literals\r\nfrom django.db import models\r\n\r\n\r\ndef rename_picture(instance, filename):\r\n    return '{0}_{1}'.format(instance.id, filename)\r\n\r\n\r\nclass Picture(models.Model):\r\n    title = models.CharField(max_length=255, null=True, blank=True)\r\n    description = models.CharField(max_length=3000, null=True, blank=True)\r\n    img_l = models.ImageField(upload_to=rename_picture, null=False)\r\n    img_m = models.ImageField(upload_to=rename_picture)\r\n    img_s = models.ImageField(upload_to=rename_picture)\r\n    img_blur = models.CharField(max_length=3000)\r\n\r\n    def __unicode__(self):\r\n        return str(self.nome)\r\n```\r\n----pictures----\r\n\r\nNow, in this example I’m using the '[storages](http://django-storages.readthedocs.io/en/latest/)' package to upload these files to my Amazon S3 bucket, but it works on local storage too.\r\n\r\n### GO FURTHER!\r\nOK, now that we have thumbnails, it's time to go a little further to speed up the application load time. Users are impatient, they demand to see something ASAP when they try to load your app, so lets show them something.\r\n\r\nLets create a preview that will be displayed only in the interval between data load from our API and the complete load of our original or thumbnails images from my Amazon S3 bucket.\r\nThere are 2 ways to do it.\r\n* Find the dominant color of a image and display it on the original image size. (Used by Google and Pinterest). I won't be showing how to implement this method, but you can look for functions that already find the right color for each image and store it with your data like the blurred image.\r\n* Create a really tiny thumbnail to be stored as a string on our database and display it. It will be blurred and fill the original image size. This way the content will be larger than choosing the dominant approach, but the result is far better.\r\n\r\nIn both cases, as the data will be really small, we can convert the data to a base64 encoded string and save it on the database and return the preview image data along with the rest of the data from the requested object. So the users browser won’t need to wait for the response from Amazon (or your local storage) to see the app. Of course, the preview image should be replaced immediately after the load of the original/thumbnail image. But you already get some seconds displaying something to hold your users attention.\r\n\r\n### Shitty resolution image preview  (A.k.a. blurred image)\r\nIn this approach I set a [9, 9] pixels size to create a extra thumbnail and encoded the data to be storage on the DB. Check the code and some results bellow:\r\n``` python\r\nfrom django import forms\r\nfrom models import Picture\r\nfrom PIL import Image\r\nimport base64\r\nimport StringIO\r\nfrom django.core.files.uploadedfile import InMemoryUploadedFile\r\n\r\n\r\ndef image_to_b64(source, size_img_blur):\r\n    data_img = StringIO.StringIO()\r\n    tiny_img = Image.open(source)\r\n    tiny_img.thumbnail(size_img_blur)\r\n    tiny_img.save(data_img, format=\"BMP\")\r\n    tiny_img.close()\r\n    encoded_b64_picture = base64.b64encode(data_img.getvalue())\r\n    return encoded_b64_picture\r\n\r\n\r\ndef generate_resized_image(source, size):\r\n    img_l = Image.open(source)\r\n    img_l.thumbnail(size, Image.ANTIALIAS)\r\n    data_img = StringIO.StringIO()\r\n    img_l.save(data_img, 'JPEG')\r\n    img_l.close()\r\n    img_temp_file = InMemoryUploadedFile(data_img, None,\r\n                                         str(size[0]) + '.jpg', 'image/jpeg',\r\n                                         data_img.len, None)\r\n    return img_temp_file\r\n\r\n\r\nclass PictureForm(forms.ModelForm):\r\n    class Meta:\r\n        model = Picture\r\n        fields = ['title', 'description', 'img_l']\r\n\r\n    def save(self, commit=True):\r\n        instance = super(PictureForm, self).save(commit=False)\r\n        source = instance.img_l\r\n        size_img_l = 1920, 1080\r\n        size_img_m = 1366, 768\r\n        size_img_s = 768, 432\r\n        size_img_blur = 9, 9\r\n        instance.save()\r\n        instance.img_blur = image_to_b64(source, size_img_blur)\r\n        img1 = generate_resized_image(source, size_img_l)\r\n        instance.img_l = img1\r\n        instance.img_m = generate_resized_image(source, size_img_m)\r\n        instance.img_s = generate_resized_image(source, size_img_s)\r\n        instance.save()\r\n        return instance\r\n\r\n```\r\nNice website to test your images:\r\n[http://codebeautify.org/base64-to-image-converter](http://codebeautify.org/base64-to-image-converter)\r\n\r\nalso, I chose to save the [9, 9] image as .bmp because it’s smaller than JPG format… Didn’t research why is that, but I think it’s because the JPG has info to decompress his data, and this extra info must be the reason to the extra bytes.\r\n\r\nThanks to [Wagner Barreto](https://br.linkedin.com/in/wagnerbarretto/pt) for many tips about the topic.\r\n\r\nUsefull links:\r\n\r\nhttps://code.facebook.com/posts/991252547593574/the-technology-behind-preview-photos/\r\n\r\nhttps://dev.opera.com/articles/native-responsive-images/\r\n\r\nhttp://davidbcalhoun.com/2011/when-to-base64-encode-images-and-when-not-to/\r\n\r\nhttps://jmperezperez.com/medium-image-progressive-loading-placeholder/\r\n\r\nhttps://manu.ninja/dominant-colors-for-lazy-loading-images\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}